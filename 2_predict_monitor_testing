// |
// | Landsat Time Series Harmonic Prediction & Monitoring
// | [valpasq@bu.edu], 2020
// |

// -------------------------------- Monitoring Parameters --------------------------------- 

var YEAR = 2017
var DAY_START = '05-01'
var DAY_END = '09-30'
var MONITOR_START = YEAR + '-' + DAY_START;
var MONITOR_END = YEAR + '-' + DAY_END;

var BASELINES_COLLECTION = ee.ImageCollection('projects/sites-project/conditionassessment_experiments_v5-2_collection')
var OUTPUT_COLLECTION = 'projects/sites-project/conditionassessment_experiments_v5-2_results/'

var EXPERIMENT = 27

// --------------------------------- Baseline Parameters ---------------------------------- 

var baseline = ee.Image(BASELINES_COLLECTION.toList(BASELINES_COLLECTION.size()).get(EXPERIMENT))
var baseline_crs = baseline.projection().crs();
var output_resolution = 30; // in meters

var VERSION = baseline.get('version').getInfo()
var DEPENDENT = baseline.get('spectral_band').getInfo()
var TS = baseline.get('time_series').getInfo()
var FREQ = baseline.get('harmonics').getInfo()
var YEAR_START = baseline.get('year_start').getInfo()
var YEAR_END = baseline.get('year_end').getInfo()
var REF_PERIOD = YEAR_START + '-' + YEAR_END

var OUTPUT_NAME = OUTPUT_COLLECTION + DEPENDENT + '_' + REF_PERIOD + '_' + FREQ + '_' + TS + '_' + MONITOR_START + '_' + MONITOR_END


// Dictionary for asset properties
var outputProperties = ee.Dictionary({
      'system:time_start': ee.Date(YEAR+'-01-01').millis(),
      'spectral_band': DEPENDENT,
      'monitor_year': YEAR,
      'monitor_start': MONITOR_START,
      'monitor_end': MONITOR_END,
      'run_version': VERSION,
      'harmonics': FREQ,
      'time_series': TS,
      'ref_period': REF_PERIOD
  });

// ---------------------------------- Map visualization ---------------------------------- 

// Colorbar
var min = -4;
var max = 0;
var palette = ['red', 'orange', 'yellow', 'blue']
var viz = {min: min, max: max, palette: palette};

var gfc = ee.Image("UMD/hansen/global_forest_change_2018_v1_6")
var gfc_tcc = 75;

// ---------------------------------- PREPROCESS ---------------------------------- 

var L8_BANDS = ['B2', 'B3', 'B4', 'B5',  'B6',  'B7', 'B10']; // Landsat OLI bands
var L457_BANDS = ['B1', 'B2', 'B3', 'B4',  'B5',  'B7', 'B6']; // Landsat TM/ETM+ bands
var LTS_NAMES = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'temp']; // Common names


var preprocess457 = function(image) {
  var mask1 = image.select(['pixel_qa']).eq(66) // Clear land
              .or(image.select(['pixel_qa']).eq(68)); // Clear water
  var mask2 = image.mask().reduce('min');
  var mask3 = image.select(['B1', 'B2', 'B3', 'B4',  'B5',  'B7']).gt(0).and(
            image.select(['B1', 'B2', 'B3', 'B4',  'B5',  'B7']).lt(10000))
            .reduce('min');
  
  return image.updateMask(mask1.and(mask2).and(mask3))
    .select(L457_BANDS).rename(LTS_NAMES)
    .copyProperties(image, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
};


var preprocess8 = function(image) {
  var mask1 = image.select(['pixel_qa']).eq(322) // Clear land
              .or(image.select(['pixel_qa']).eq(324)); // Clear water
  var mask2 = image.mask().reduce('min');
  var mask3 = image.select(['B2', 'B3', 'B4', 'B5',  'B6',  'B7']).gt(0).and(
            image.select(['B2', 'B3', 'B4', 'B5',  'B6',  'B7']).lt(10000))
            .reduce('min');
               
  return image.updateMask(mask1.and(mask2).and(mask3))
      .select(L8_BANDS).rename(LTS_NAMES) // Map legacy band names
      .copyProperties(image, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
};


var cloudScore = function(image) {
  // A helper to apply an expression and linearly rescale the output.
  var rescale = function(image, exp, thresholds) {
    return image.expression(exp, {image: image})
        .divide(10000) // need to divide by 10000 (SR)
        .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
  };

  // Compute several indicators of cloudyness and take the minimum of them.
  var score = ee.Image(1.0);
  
  // Clouds are reasonably bright in the blue band.
  score = score.min(rescale(image, 'image.blue', [0.1, 0.3]));

  // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(image, 'image.red + image.green + image.blue', [0.2, 0.8]));

  // Clouds are reasonably bright in all infrared bands.
  score = score.min(
      rescale(image, 'image.nir + image.swir1 + image.swir2', [0.3, 0.8]));

  // Clouds are reasonably cool in temperature.
  score = score.min(rescale(image, 'image.temp', [300, 290]));

  // However, clouds are not snow.
  var ndsi = image.normalizedDifference(['green', 'swir1']);
  return score.min(rescale(ndsi, 'image', [0.8, 0.6]));

}; 


var addCloudScore = function(image) {
      // Invert the cloudscore so 1 is least cloudy, and rename the band.
      var score = cloudScore(image.select(LTS_NAMES));
      score = ee.Image(1).subtract(score).select([0], ['cloudscore']);
      return image.addBands(score);
// REF: https://gis.stackexchange.com/questions/280400/
// cloud-cover-percentage-in-google-earth-engine 
}


var maskCloudScore = function(image) {
  var qa = image.select('cloudscore');

  var mask = qa.gte(0.8);
  return image.updateMask(mask)
      .copyProperties(image, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
}
// SOURCE: https://gis.stackexchange.com/questions/280400/
// cloud-cover-percentage-in-google-earth-engine  


var spectralTransforms = function(img){
  // make sure index string in upper case
  var index = DEPENDENT.toUpperCase();
  
  var scaled = img.divide(10000);

  var dict = {
    blue: scaled.select("blue"),
    green: scaled.select("green"), 
    red: scaled.select("red"),
    nir: scaled.select("nir"),
    swir1: scaled.select("swir1"),
    swir2: scaled.select("swir2"),
  };
  
  var indexImg;
  switch (index){
    case 'NBR':
      indexImg = scaled.normalizedDifference(['nir', 'swir2'])
        .rename("nbr");
      break;
    case 'NDMI':
      indexImg = scaled.normalizedDifference(['nir', 'swir1'])
        .rename("ndmi");
      break;
    case 'NDVI':
      indexImg = scaled.normalizedDifference(['nir', 'red'])
        .rename("ndvi");
      break;
    case 'NDSI':
      indexImg = scaled.normalizedDifference(['green', 'swir1'])
        .rename("ndsi");
      break;
    case 'EVI':
      indexImg = scaled.expression("2.5 * ((nir - red) / (nir + 6 * red - 7.5 * blue + 1))", dict)
        .rename("evi");
      break;
    case 'TCB':
      indexImg = scaled.expression("0.2043*blue + 0.4158*green + 0.5524*red + 0.5741*nir + 0.3124*swir1 + 0.2303*swir2", dict)
        .rename("tcb");
      break;
    case 'TCG':
      indexImg = scaled.expression("-0.1603*blue - 0.2819*green - 0.4934*red + 0.7940*nir - 0.0002*swir1 - 0.1446*swir2", dict)
        .rename("tcg");
      break;
    case 'TCW':
      indexImg = scaled.expression("0.0315*blue + 0.2021*green + 0.3102*red + 0.1594*nir - 0.6806*swir1 - 0.6109*swir2", dict)
        .rename("tcw");
      break;
    case 'SR':
      indexImg = scaled.select('nir').divide(scaled.select('red'))
        .rename("sr");
      break;

    default:
      print('The index you provided is not supported');
  }

  return indexImg.reproject(baseline_crs, null, output_resolution)
    .copyProperties(img, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
}


var getNames = function(base, list) {
  return ee.List(list).map(function(i) { 
    return ee.String(base).cat(ee.Number(i).int());
  });
};


var addConstant = function(image) {
  return image.addBands(ee.Image(1))
    .setDefaultProjection(baseline_crs);
};


var addTime = function(image) {
  // Compute time in fractional years since the epoch.
  var date = ee.Date(image.get('system:time_start'));
  var years = date.difference(ee.Date('1970-01-01'), 'year');
  var timeRadians = ee.Image(years.multiply(2 * Math.PI));
  return image.addBands(timeRadians.rename('t').float())
    .setDefaultProjection(baseline_crs);
};


var addHarmonics = function(freqs) {
  return function(image) {
    // Make an image of frequencies.
    var frequencies = ee.Image.constant(freqs)
      .setDefaultProjection(baseline_crs);
    // This band should represent time in radians.
    var time = ee.Image(image).select('t');
    // Get the cosine terms.
    var cosines = time.multiply(frequencies).cos()
      .rename(cosNames);
    // Get the sin terms.
    var sines = time.multiply(frequencies).sin()
      .rename(sinNames);
    return image.addBands(cosines).addBands(sines);
  };
};


// Function to build monitoring collection
var monitorTS = function(clipBound, MONITOR_START, MONITOR_END) {
  
// Get Landsat 5 imagery
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
      .filterDate(MONITOR_START, MONITOR_END)  
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", 80)
      .map(preprocess457) 
      .map(function(image) {return image.set('SENSING_TIME', ee.String(image.get('SENSING_TIME')).split('T').get(0))})
      
  // Get Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
      .filterDate(MONITOR_START, MONITOR_END) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", 80)
      .map(preprocess457) 
      .map(function(image) {return image.set('SENSING_TIME', ee.String(image.get('SENSING_TIME')).split('T').get(0))})
  
  // Get  Landsat 8 imagery
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
      .filterDate(MONITOR_START, MONITOR_END) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", 80)
      .map(preprocess8)  
      .map(function(image) {return image.set('SENSING_TIME', ee.String(image.get('SENSING_TIME')).split('T').get(0))})
  
  // FINAL LTS COLLECTION
  var collection = collection5.merge(collection7).merge(collection8)
      .sort('system:time_start') 
  
  // ENDLAP FILTERING
  // Get all distinct acquisition dates.
  var acquisitions = ee.List(collection.aggregate_array('SENSING_TIME'))
    .distinct()
  var startTS = acquisitions.get(0) // start of acquisitions for TS period
  
  // Take median for each acquisition date (Path)
  var filterEndlap = ee.ImageCollection.fromImages(acquisitions.map(function(d) {
    var date = ee.Date(d)
    var date2 = date.advance(24, 'hour')
    
    return collection.filterDate(date, date2).median()
      .set('system:time_start', date.millis())
  }));
  
  // Mask and transform
  var monitorC = filterEndlap
      .map(addCloudScore)
      .map(maskCloudScore) // mask based on simple cloud score
      .map(spectralTransforms) // calculate spectral transforms
      
  // Return image collection for monitoring period
  return monitorC;
  
  };
  
  
// Function to add predicted value
var addPrediction = function(image) {
  var prediction = image.select(independents)
      .multiply(baseline.select(independents))
      .reduce('sum')
      .rename('fitted')
  var rmse = baseline.select('rmse').rename('rmse')
  var nobs = baseline.select('nobs').rename('nobs')
  var t = baseline.select('t').rename('trend')
  return image.addBands(prediction)
    .addBands(rmse).addBands(nobs).addBands(t);
}

// Function to calculate residuals (observed - predicted)
var addResidual = function(image) {
  var observed = image.select(DEPENDENT)
  var prediction = image.select(independents)
      .multiply(baseline.select(independents))
      .reduce('sum')
  var score = observed.subtract(prediction)
      .divide(baseline.select('rmse'))
      // .multiply(image.select('mask'))
  return image.addBands(score.rename('score'));
}


// --------------------------------- Analysis ---------------------------------- 

// Get baseline image
baseline = baseline.divide(10000)

// Get study area boundary
var clip_bound = baseline.geometry()

// get frequencies
if (FREQ == 'h13') {
  var harmonicFrequencies = ee.List([1,3]);
  
} else if (FREQ == 'h12') {
  var harmonicFrequencies = ee.List([1,2]);
}

// Construct lists of names for the harmonic terms.
var cosNames = getNames('cos_', harmonicFrequencies);
var sinNames = getNames('sin_', harmonicFrequencies);

// Independent variables.
var independents = ee.List(['constant', 't'])
  .cat(cosNames).cat(sinNames);

// Get monitoring period imagery
var monitor = monitorTS(clip_bound, MONITOR_START, MONITOR_END);

// Add constant, time, and coefficients to monitoring collection.
var harmonicLandsat = monitor.select(DEPENDENT)
  .map(addConstant)
  .map(addTime)
  .map(addHarmonics(harmonicFrequencies));

// Add predictions and scores
var collectPredictions = harmonicLandsat
  .map(addPrediction)
  .map(addResidual);

print(collectPredictions)

var mean = collectPredictions.select('score').reduce('mean');
var stddev = collectPredictions.select('score').reduce('stdDev');
var nobs = collectPredictions.select('score').reduce('count');

// Average over monitoring period
var assessment = ee.Image(mean.addBands(stddev).addBands(nobs)
    .clip(clip_bound)
    .setMulti(outputProperties))
print(assessment)

// Mask non-forest
var gfc_mask = gfc.select('treecover2000').gte(gfc_tcc).reproject(baseline_crs, null, 30)
var assessment_masked = assessment.updateMask(gfc_mask)

Map.addLayer(assessment_masked.select('score_count'), {min:0, max:15})
Map.addLayer(assessment_masked.select('score_stdDev'))
Map.addLayer(assessment_masked.select('score_mean'), viz)

// ------------------------------------- Export -------------------------------------- 

Export.image.toAsset({
  image: assessment,
  description: DEPENDENT + '_' + YEAR_START + '-' + YEAR_END + '_monitor',
  assetId: OUTPUT_NAME,
  region: clip_bound,
  crs: baseline_crs,
  scale: output_resolution,
  maxPixels: 1e13,
})



// ---------------------------------- Map settings ---------------------------------- 

var style = {
  'Figure': [{
      featureType: 'all',
      stylers: [{ color: '#000000'}]
  }]
};

Map.setOptions(null, style);


  