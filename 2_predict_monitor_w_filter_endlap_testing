// |
// | Landsat Time Series Harmonic Prediction & Monitoring
// | [valpasq@bu.edu], 2020
// |


// ---------------------------------- Imports & Outputs ---------------------------------- 

// Specify collection with experiments from 1_baseline_generator
var BASELINES_COLLECTION = ee.ImageCollection('projects/sites-project/baselines_v5-3_by_path')

// Specify collection for saving monitoring results (created using Assets Manager)
var OUTPUT_COLLECTION = 'projects/sites-project/baselines_v5-3_by_path_monitoring/'

var utils = require('users/valeriepasquarella/condition_monitoring:utils.js');


// -------------------------------- Monitoring Parameters --------------------------------- 

var YEAR = 2017
var DAY_START = '05-01' 
var DAY_END = '09-30'

var CC_THRESH = 50;   // maximum CLOUD_COVER_LAND 
var OBS_MIN = 75;     // exclude baseline models fit with less than minimum nobs


// -------------------------------- Monitoring Setup -------------------------------- 

var monitor_start = YEAR + '-' + DAY_START;
var monitor_end = YEAR + '-' + DAY_END;

var experiments = BASELINES_COLLECTION.aggregate_array('name').distinct()
var num_experiments = experiments.size().getInfo()
print(experiments)
print(num_experiments)

var paths = BASELINES_COLLECTION.aggregate_array('WRS_PATH').distinct()
var num_paths = paths.size().getInfo()

// -------------------------------- Visualization -------------------------------- 

var min = -4;
var max = 0;
var palette = ['red', 'orange', 'yellow', 'blue']
var viz = {min: min, max: max, palette: palette};

// ---------------------------------- Functions ---------------------------------- 

var L8_BANDS = ['B2', 'B3', 'B4', 'B5',  'B6',  'B7', 'B10']; // Landsat OLI bands
var L457_BANDS = ['B1', 'B2', 'B3', 'B4',  'B5',  'B7', 'B6']; // Landsat TM/ETM+ bands
var LTS_NAMES = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'temp']; // Common names


var preprocess457 = function(image) {
  var mask1 = image.select(['pixel_qa']).eq(66) // Clear land
              .or(image.select(['pixel_qa']).eq(68)); // Clear water
  var mask2 = image.mask().reduce('min');
  var mask3 = image.select(['B1', 'B2', 'B3', 'B4',  'B5',  'B7']).gt(0).and(
            image.select(['B1', 'B2', 'B3', 'B4',  'B5',  'B7']).lt(10000))
            .reduce('min');
  
  return image.updateMask(mask1.and(mask2).and(mask3))
    .select(L457_BANDS).rename(LTS_NAMES)
    .copyProperties(image);
};


var preprocess8 = function(image) {
  var mask1 = image.select(['pixel_qa']).eq(322) // Clear land
              .or(image.select(['pixel_qa']).eq(324)); // Clear water
  var mask2 = image.mask().reduce('min');
  var mask3 = image.select(['B2', 'B3', 'B4', 'B5',  'B6',  'B7']).gt(0).and(
            image.select(['B2', 'B3', 'B4', 'B5',  'B6',  'B7']).lt(10000))
            .reduce('min');
               
  return image.updateMask(mask1.and(mask2).and(mask3))
      .select(L8_BANDS).rename(LTS_NAMES) // Map legacy band names
      .copyProperties(image);
};


var cloudScore = function(image) {
  // A helper to apply an expression and linearly rescale the output.
  var rescale = function(image, exp, thresholds) {
    return image.expression(exp, {image: image})
        .divide(10000) // need to divide by 10000 (SR)
        .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
  };

  // Compute several indicators of cloudyness and take the minimum of them.
  var score = ee.Image(1.0);
  
  // Clouds are reasonably bright in the blue band.
  score = score.min(rescale(image, 'image.blue', [0.1, 0.3]));

  // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(image, 'image.red + image.green + image.blue', [0.2, 0.8]));

  // Clouds are reasonably bright in all infrared bands.
  score = score.min(
      rescale(image, 'image.nir + image.swir1 + image.swir2', [0.3, 0.8]));

  // Clouds are reasonably cool in temperature.
  score = score.min(rescale(image, 'image.temp', [300, 290]));

  // However, clouds are not snow.
  var ndsi = image.normalizedDifference(['green', 'swir1']);
  return score.min(rescale(ndsi, 'image', [0.8, 0.6]));

}; 


var addCloudScore = function(image) {
      // Invert the cloudscore so 1 is least cloudy, and rename the band.
      var score = cloudScore(image.select(LTS_NAMES));
      score = ee.Image(1).subtract(score).select([0], ['cloudscore']);
      return image.addBands(score);
// REF: https://gis.stackexchange.com/questions/280400/
// cloud-cover-percentage-in-google-earth-engine 
}


var maskCloudScore = function(image) {
  var qa = image.select('cloudscore');

  var mask = qa.gte(0.8);
  return image.updateMask(mask)
      .copyProperties(image);
}
// SOURCE: https://gis.stackexchange.com/questions/280400/
// cloud-cover-percentage-in-google-earth-engine  


var spectralTransforms = function(img){
  // make sure index string in upper case
  var index = DEPENDENT.toUpperCase();
  
  var scaled = img.divide(10000);

  var dict = {
    blue: scaled.select("blue"),
    green: scaled.select("green"), 
    red: scaled.select("red"),
    nir: scaled.select("nir"),
    swir1: scaled.select("swir1"),
    swir2: scaled.select("swir2"),
  };
  
  var indexImg;
  switch (index){
    case 'NBR':
      indexImg = scaled.normalizedDifference(['nir', 'swir2'])
        .rename("nbr");
      break;
    case 'NDMI':
      indexImg = scaled.normalizedDifference(['nir', 'swir1'])
        .rename("ndmi");
      break;
    case 'NDVI':
      indexImg = scaled.normalizedDifference(['nir', 'red'])
        .rename("ndvi");
      break;
    case 'NDSI':
      indexImg = scaled.normalizedDifference(['green', 'swir1'])
        .rename("ndsi");
      break;
    case 'EVI':
      indexImg = scaled.expression("2.5 * ((nir - red) / (nir + 6 * red - 7.5 * blue + 1))", dict)
        .rename("evi");
      break;
    case 'TCB':
      indexImg = scaled.expression("0.2043*blue + 0.4158*green + 0.5524*red + 0.5741*nir + 0.3124*swir1 + 0.2303*swir2", dict)
        .rename("tcb");
      break;
    case 'TCG':
      indexImg = scaled.expression("-0.1603*blue - 0.2819*green - 0.4934*red + 0.7940*nir - 0.0002*swir1 - 0.1446*swir2", dict)
        .rename("tcg");
      break;
    case 'TCW':
      indexImg = scaled.expression("0.0315*blue + 0.2021*green + 0.3102*red + 0.1594*nir - 0.6806*swir1 - 0.6109*swir2", dict)
        .rename("tcw");
      break;
    case 'SR':
      indexImg = scaled.select('nir').divide(scaled.select('red'))
        .rename("sr");
      break;

    default:
      print('The index you provided is not supported');
  }

  return indexImg//.reproject(baseline_crs, null, output_resolution)
    .copyProperties(img, ["system:time_start", "WRS_PATH", "WRS_ROW", "SENSING_TIME"]);
}


var getNames = function(base, list) {
  return ee.List(list).map(function(i) { 
    return ee.String(base).cat(ee.Number(i).int());
  });
};


var addConstant = function(image) {
  return image.addBands(ee.Image(1))
    // .setDefaultProjection(baseline_crs);
};


var addTime = function(image) {
  // Compute time in fractional years since the epoch.
  var date = ee.Date(image.get('system:time_start'));
  var years = date.difference(ee.Date('1970-01-01'), 'year');
  var timeRadians = ee.Image(years.multiply(2 * Math.PI));
  return image.addBands(timeRadians.rename('t').float())
    // .setDefaultProjection(baseline_crs);
};


var addHarmonics = function(freqs) {
  return function(image) {
    // Make an image of frequencies.
    var frequencies = ee.Image.constant(freqs)
      // .setDefaultProjection(baseline_crs);
    // This band should represent time in radians.
    var time = ee.Image(image).select('t');
    // Get the cosine terms.
    var cosines = time.multiply(frequencies).cos()
      .rename(cosNames);
    // Get the sin terms.
    var sines = time.multiply(frequencies).sin()
      .rename(sinNames);
    return image.addBands(cosines).addBands(sines);
  };
};


// Function to build monitoring collection
var monitorTS = function(clipBound, monitor_start, monitor_end) {
  
// Get Landsat 5 imagery
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
      .filterDate(monitor_start, monitor_end)  
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(preprocess457) 
    
  // Get Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(preprocess457) 

  // Get  Landsat 8 imagery
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(preprocess8)  

  // FINAL LTS COLLECTION
  var collection = collection5.merge(collection7).merge(collection8)
      .map(function(image) {return image.set({
          'SENSING_TIME': ee.String(image.get('SENSING_TIME')).split('T').get(0), 
          'WRS_PATH': image.get('WRS_PATH')})
      })
      .map(addCloudScore)
      .map(maskCloudScore) 
      .map(spectralTransforms)
      .sort('system:time_start') 
      
  // ENDLAP FILTERING
  var acquisitions = collection.aggregate_array('SENSING_TIME').distinct()
  
  // Take mean for each acquisition date (Path)
  var monitorC = ee.ImageCollection.fromImages(acquisitions.map(function(d) {
    var date = ee.Date(d)
    var date2 = date.advance(24, 'hour')
    var path = collection.filterDate(date, date2).first().get('WRS_PATH')
    
    return collection.filterDate(date, date2).mean()
      .set({
        'system:time_start': date.millis(), 
        'WRS_PATH': path
      })
  }));
  
  // Return image collection for monitoring period
  return monitorC;
  
  };
  
  
// Function to add predicted value
var addPrediction = function(image) {
  var prediction = image.select(independents)
      .multiply(baseline.select(independents))
      .reduce('sum')
      .rename('fitted')
  var rmse = baseline.select('rmse').rename('rmse')
  var nobs = baseline.select('nobs').rename('nobs')
  var t = baseline.select('t').rename('trend')
  return image.addBands(prediction)
    .addBands(rmse).addBands(nobs).addBands(t);
}

// Function to calculate scores
var addScore = function(image) {
  var observed = image.select(DEPENDENT)
  var prediction = image.select('fitted')
  var score = observed.subtract(prediction)
      .divide(image.select('rmse'))
      
  return image.addBands(score.rename('score'));
}


// --------------------------------- PREDICT ---------------------------------- 

// Loop over experiments in baselines collection
for(var experiment = 0; experiment < num_experiments; experiment++){
  
  var experiment_name = experiments.get(experiment)
  print('Experiment:', experiment_name)
  var baselines = ee.ImageCollection(BASELINES_COLLECTION
    .filterMetadata('name', 'equals', experiment_name))
  print('Baseline collection:', baselines)

  
  var VERSION = baselines.first().get('version').getInfo()
  var DEPENDENT = baselines.first().get('spectral_band').getInfo()
  var TS = baselines.first().get('time_series').getInfo()
  var FREQ = baselines.first().get('harmonics').getInfo()
  var YEAR_START = baselines.first().get('year_start').getInfo()
  var YEAR_END = baselines.first().get('year_end').getInfo()
  var REF_PERIOD = YEAR_START + '-' + YEAR_END
  
  var OUTPUT_NAME = OUTPUT_COLLECTION + DEPENDENT + '_' + REF_PERIOD + '_' + FREQ + '_' + TS + '_' + monitor_start + '_' + monitor_end

  // Get study area boundary
  var clip_bound = baselines.geometry().bounds()
  // Map.addLayer(clip_bound)
  
  // get frequencies
  if (FREQ == 'h13') {
    var harmonicFrequencies = ee.List([1,3]);
    
  } else if (FREQ == 'h12') {
    var harmonicFrequencies = ee.List([1,2]);
  }
  
  // Construct lists of names for the harmonic terms.
  var cosNames = getNames('cos_', harmonicFrequencies);
  var sinNames = getNames('sin_', harmonicFrequencies);
  
  // Independent variables.
  var independents = ee.List(['constant', 't'])
    .cat(cosNames).cat(sinNames);
  
  // Get monitoring period imagery
  var monitor = monitorTS(clip_bound, monitor_start, monitor_end);
  print('Full monitoring collection:', monitor)
  
//   var paths = BASELINES_COLLECTION.aggregate_array('WRS_PATH').distinct()
// var num_paths = paths.size().getInfo()

  for(var i = 0; i < num_paths; i++){
    var path = paths.get(i)
    print('Path:', path)
    var baseline = baselines
      .filterMetadata('WRS_PATH', 'equals', path)
      .first()
      .divide(10000)
    baseline = baseline.updateMask(baseline.select('nobs').gte(OBS_MIN))
    print(baseline.projection().crs())

    var monitor_subset = monitor.filterMetadata('WRS_PATH', 'equals', path)
    print('Monitoring dates within Path:', monitor_subset)
  
    // Add constant, time, and coefficients to monitoring collection.
    var harmonicLandsat = monitor_subset.select(DEPENDENT)
      .map(addConstant)
      .map(addTime)
      .map(addHarmonics(harmonicFrequencies));
    
    // Add predictions and scores
    var collectPredictions = harmonicLandsat
      .map(addPrediction)
      .map(addScore);
    print('Collection of results for Path', collectPredictions)
    
    var mean = collectPredictions.select('score').reduce('mean');
    var stddev = collectPredictions.select('score').reduce('stdDev');
    var nobs = collectPredictions.select('score').reduce('count');
    
    
        // Dictionary for asset properties
    var outputProperties = ee.Dictionary({
          'system:time_start': ee.Date(monitor_start).millis(),
          'spectral_band': DEPENDENT,
          'monitor_year': YEAR,
          'monitor_start': monitor_start,
          'monitor_end': monitor_end,
          'run_version': VERSION,
          'harmonics': FREQ,
          'time_series': TS,
          'ref_period': REF_PERIOD,
          'name': experiment_name,
          'WRS_PATH': path
      });
    
    // Average over monitoring period
    var assessment = ee.Image(mean.addBands(stddev).addBands(nobs)
        .clip(clip_bound)
        .setMulti(outputProperties))
    print('Assessment:', assessment)
    
    var layer_name = 'Path ' + PATH
    Map.addLayer(assessment.select('score_mean'), viz, layer_name)
    
    Export.image.toAsset({
      image: assessment,
      description: DEPENDENT + '_' + YEAR_START + '-' + YEAR_END + '_monitor-' + PATH,
      assetId: OUTPUT_NAME + '_p' + PATH,
      region: clip_bound,
      crs: baseline.projection().crs(),
      scale: 30,
      maxPixels: 1e13,
    })

  }
  
}





  