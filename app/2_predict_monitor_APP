// |
// | Forest Condition Monitoring v3.0
// | [valpasq@bu.edu], 2020
// |


// ---------------------------------- Imports & Outputs ---------------------------------- 
 
var utils = require('users/valeriepasquarella/condition_monitoring:utils.js');

// Specify collection with experiments from 1_baseline_generator
var BASELINES_COLLECTION = ee.ImageCollection('projects/sites-project/baselines_v6-3_by_state')


// -------------------------------- Monitoring Parameters --------------------------------- 

var YEAR = 2017         // Monitoring year
var DAY_START = '05-01' // Date to start monitoring
var DAY_END = '09-30'   // Date to end monitoring

var CC_THRESH = 50;     // maximum CLOUD_COVER_LAND 

// -------------------------------- Monitoring Setup -------------------------------- 

var monitor_start = YEAR + '-' + DAY_START;
var monitor_end = YEAR + '-' + DAY_END;


// -------------------------------- Visualization -------------------------------- 
// Default visualization palette used in Pasquarella et al. 2017, 2018

var min = -4;
var max = 0;
var palette = ['red', 'orange', 'yellow', 'blue']
var viz = {min: min, max: max, palette: palette};


var MIN_TCC = 75;
var NLCD = ee.Image('USGS/NLCD/NLCD2016')

var tcc_mask = NLCD.select('percent_tree_cover')
  .gte(MIN_TCC)
  

// ---------------------------------- Functions ---------------------------------- 

var spectralTransforms = function(img){
  // make sure index string in upper case
  var index = DEPENDENT.toUpperCase();
  
  var scaled = img.divide(10000);

  var dict = {
    blue: scaled.select("blue"),
    green: scaled.select("green"), 
    red: scaled.select("red"),
    nir: scaled.select("nir"),
    swir1: scaled.select("swir1"),
    swir2: scaled.select("swir2"),
  };
  
  var indexImg;
  switch (index){
    case 'NDVI':
      indexImg = scaled.normalizedDifference(['nir', 'red'])
        .rename("ndvi");
      break;
    case 'EVI':
      indexImg = scaled.expression("2.5 * ((nir - red) / (nir + 6 * red - 7.5 * blue + 1))", dict)
        .rename("evi");
      break;
    case 'TCG':
      indexImg = scaled.expression("-0.1603*blue - 0.2819*green - 0.4934*red + 0.7940*nir - 0.0002*swir1 - 0.1446*swir2", dict)
        .rename("tcg");
      break;
    case 'SR':
      indexImg = scaled.select('nir').divide(scaled.select('red'))
        .rename("sr");
      break;

    default:
      print('The index you provided is not supported');
  }

  return indexImg//.reproject(baseline_crs, null, output_resolution)
    .copyProperties(img, ["system:time_start", "WRS_PATH", "WRS_ROW", "SENSING_TIME"]);
}


var getNames = function(base, list) {
  return ee.List(list).map(function(i) { 
    return ee.String(base).cat(ee.Number(i).int());
  });
};


var addConstant = function(image) {
  return image.addBands(ee.Image(1))
    // .setDefaultProjection(baseline_crs);
};


var addTime = function(image) {
  // Compute time in fractional years since the epoch.
  var date = ee.Date(image.get('system:time_start'));
  var years = date.difference(ee.Date('1970-01-01'), 'year');
  var timeRadians = ee.Image(years.multiply(2 * Math.PI));
  return image.addBands(timeRadians.rename('t').float())
    .setDefaultProjection(baseline.projection().crs());
};


var addHarmonics = function(freqs) {
  return function(image) {
    // Make an image of frequencies.
    var frequencies = ee.Image.constant(freqs)
      // .setDefaultProjection(baseline_crs);
    // This band should represent time in radians.
    var time = ee.Image(image).select('t');
    // Get the cosine terms.
    var cosines = time.multiply(frequencies).cos()
      .rename(cosNames);
    // Get the sin terms.
    var sines = time.multiply(frequencies).sin()
      .rename(sinNames);
    return image.addBands(cosines).addBands(sines);
  };
};


// Function to build monitoring collection
var monitorTS = function(clipBound, monitor_start, monitor_end) {
  
// Get Landsat 5 imagery
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
      .filterDate(monitor_start, monitor_end)  
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 
    
  // Get Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 

  // Get  Landsat 8 imagery
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess8)  

  // FINAL LTS COLLECTION
  var collection = collection5.merge(collection7).merge(collection8)
      .map(function(image) {return image.set({
          'SENSING_TIME': ee.String(image.get('SENSING_TIME')).split('T').get(0), 
          'WRS_PATH': image.get('WRS_PATH')})
      })
      .map(utils.addCloudScore)
      .map(utils.maskCloudScore) 
      .map(spectralTransforms)
      .sort('system:time_start') 
      
  // ENDLAP FILTERING
  var acquisitions = collection.aggregate_array('SENSING_TIME').distinct()
  
  // Take mean for each acquisition date (Path)
  var monitorC = ee.ImageCollection.fromImages(acquisitions.map(function(d) {
    var date = ee.Date(d)
    var date2 = date.advance(24, 'hour')
    var path = collection.filterDate(date, date2).first().get('WRS_PATH')
    
    return collection.filterDate(date, date2).mean()
      .set({
        'system:time_start': date.millis(), 
        'WRS_PATH': path
      })
  }));
  
  // Return image collection for monitoring period
  return monitorC;
  
  };
  
  
// Function to add predicted value
var addPrediction = function(image) {
  var prediction = image.select(independents)
      .multiply(baseline.select(independents))
      .reduce('sum')
      .rename('fitted')
  var rmse = baseline.select('rmse').rename('rmse')
  var nobs = baseline.select('nobs').rename('nobs')
  var t = baseline.select('t').rename('trend')
  return image.addBands(prediction)
    .addBands(rmse).addBands(nobs).addBands(t);
}

// Function to calculate scores
var addScore = function(image) {
  var observed = image.select(DEPENDENT)
  var prediction = image.select('fitted')
  var score = observed.subtract(prediction)
      .divide(image.select('rmse'))
      
  return image.addBands(score.rename('score'));
}

// END FUNCTIONS

// ---------------------------------- MAIN PANELS ---------------------------------- 

// Set up Control Panel 
var controlPanel = ui.Panel({
  layout: ui.Panel.Layout.flow('vertical'),
  style: {width: '340px',
  backgroundColor: 'white'}
});

// // Set up Chart Panel
// var chartPanel = ui.Panel({
//     style: {
//       height: '230px',
//       width: '300px',
//       position: 'bottom-left',
//       backgroundColor: 'rgba(255, 255, 255, 0.5)'
//     }
//   });
  
// Set up Map 
var map = ui.Map();


// ---------------------------------- SECONDARY PANELS ---------------------------------- 

// Style "heading" labels
var visLabels = {
  fontWeight: 'bold', 
  fontSize: '14px', 
  width: '325px',
  padding: '4px 4px 4px 4px',
  color: 'rgba(0, 0, 0, 0.5)', 
  backgroundColor: 'rgba(0, 0, 0, 0.1)',
  textAlign: 'left'
  
};

// --- TITLE PANEL with Instructions
var toolLabel = ui.Label('Forest Condition Assessment', {
    fontWeight: 'bold', 
    fontSize: '20px', 
    padding: '4px 4px 4px 4px',
    width: '325px',
    color: 'white',
    backgroundColor: 'rgba(0, 0, 0, 0.5)'
})
var toolDesc = ui.Label('')

var instruct = ui.Label('This tool uses harmonic baseline models to assess changes in vegetation condition during the specified monitoring period.')
var headerPanel = ui.Panel([toolLabel, instruct])


// Add secondary panels
controlPanel.add(headerPanel)

// --------------------------------- PREDICT ---------------------------------- 

var DEPENDENT = 'tcg'
var TS = 'full'
var STATES = ee.List(['PA', 'MA', 'RI', 'CT'])
var MIN_OBS = 30;

// var OUTPUT_CRS = 'EPSG:4326'

var REDUCER = 'median'

var experiment_baselines = ee.ImageCollection(BASELINES_COLLECTION
  .filterMetadata('spectral_band', 'equals', DEPENDENT)
  .filter(ee.Filter.inList('state', STATES)) 
  .filterMetadata('harmonics', 'equals', 'h13')
  .filterMetadata('time_series', 'equals', TS))
print(experiment_baselines)

  // Get WRS2 paths
var paths = experiment_baselines.aggregate_array('WRS_PATH').distinct()
var num_paths = paths.size().getInfo()

// Get study area boundary
var clip_bound = experiment_baselines.geometry().bounds()

// Harmonic frequences - use 12-month/4-month (h13)
var harmonicFrequencies = ee.List([1,3]);
  
// Construct lists of names for the harmonic terms.
var cosNames = getNames('cos_', harmonicFrequencies);
var sinNames = getNames('sin_', harmonicFrequencies);

// Independent variables.
var independents = ee.List(['constant', 't'])
  .cat(cosNames).cat(sinNames);

// Get monitoring period imagery
var monitor = monitorTS(clip_bound, monitor_start, monitor_end);

var baseline = []
var final_scores = []

var assess = function(img){
  baseline = img.updateMask(img.select('nobs').gte(MIN_OBS))
  
  // Add constant, time, and coefficients to monitoring collection.
  var harmonicLandsat = monitor_subset.select(DEPENDENT)
    .map(addConstant)
    .map(addTime)
    .map(addHarmonics(harmonicFrequencies));
  
  // Add predictions and scores
  var collectPredictions = harmonicLandsat
    .map(addPrediction)
    .map(addScore);

  var score = collectPredictions.select('score').reduce('mean').rename('score')
  
  return ee.Image(score);

}

for(var i = 0; i < num_paths; i++){
  var path = paths.get(i).getInfo()
  
  var baselines = experiment_baselines.filterMetadata('WRS_PATH', 'equals', path)
  var monitor_subset = monitor.filterMetadata('WRS_PATH', 'equals', path)
  
  // Assessment for each path
  var results = baselines.map(assess)
  print(results)
  
  // Combine all model results 
  var assessment = results.select('score')
    .reduce(REDUCER).rename('score').clip(clip_bound)
    .updateMask(tcc_mask)
    

  var layer_name = 'Path ' + path
  map.addLayer(assessment.select('score'), viz, layer_name, false)
  
  // Image where each band is a Path-level assessment
  final_scores = ee.Image(final_scores).addBands(assessment)

}

// Combine across Paths
print(final_scores)
map.addLayer(final_scores.reduce('mean'), viz)
  
// }


ui.root.clear();
ui.root.add(controlPanel);
ui.root.add(map);

  