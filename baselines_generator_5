/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var wrs2 = ee.FeatureCollection("projects/google/wrs2_descending"),
    roi = ee.FeatureCollection("users/valeriepasquarella/simplifiedNewEngland_2");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// |
// | Landsat Time Series Harmonic Baseline Generator
// | [valpasq@bu.edu], 2020
// |

var VERSION = '5-0';

// ---------------------------------- Model Parameters ---------------------------------- 

var START_YEAR = 2005;  // Starts 01-01
var END_YEAR = 2010;    // Ends 12-31

var DEPENDENT = 'tcg';  // Select spectral transform   
var HARMONICS = 'h13';  // 'h12' => 12 & 6 month, 'h13' => 12 & 4 month
var TS = 'full';        // 'full' or '16d' (limits L7 use)

var OUTPUT_MULTIPLIER = 10000; // To convert asset output to int
var OUTPUT_CRS = 'EPSG:5070'   // Projection for export (scenes may span UTM zones)


// Dictionary for asset properties
var outputProperties = ee.Dictionary({
    'system:time_start': ee.Date(START_YEAR+'-01-01').millis(),
    'system:time_end': ee.Date(END_YEAR+'-12-31').millis(),
    'spectral_band': DEPENDENT,
    'year_start': START_YEAR,
    'year_end': END_YEAR,
    'version': VERSION,
    'harmonics': HARMONICS,
    'time_series': TS,
});

// 'Legacy' band renaming
var L8_BANDS = ['B2', 'B3', 'B4', 'B5',  'B6',  'B7', 'B10']; // Landsat OLI bands
var L457_BANDS = ['B1', 'B2', 'B3', 'B4',  'B5',  'B7', 'B6']; // Landsat TM/ETM+ bands
var LTS_NAMES = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'temp']; // Common names


// ------------------------------------- Functions -------------------------------------- 

var preprocess457 = function(image) {
  var mask1 = image.select(['pixel_qa']).eq(66) // Clear land
              .or(image.select(['pixel_qa']).eq(68)); // Clear water
  var mask2 = image.mask().reduce('min');
  var mask3 = image.select(['B1', 'B2', 'B3', 'B4',  'B5',  'B7']).gt(0).and(
            image.select(['B1', 'B2', 'B3', 'B4',  'B5',  'B7']).lt(10000))
            .reduce('min');
  
  return image.updateMask(mask1.and(mask2).and(mask3))
    .select(L457_BANDS).rename(LTS_NAMES)
    .copyProperties(image, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
};

var preprocess8 = function(image) {
  var mask1 = image.select(['pixel_qa']).eq(322) // Clear land
              .or(image.select(['pixel_qa']).eq(324)); // Clear water
  var mask2 = image.mask().reduce('min');
  var mask3 = image.select(['B2', 'B3', 'B4', 'B5',  'B6',  'B7']).gt(0).and(
            image.select(['B2', 'B3', 'B4', 'B5',  'B6',  'B7']).lt(10000))
            .reduce('min');
               
  return image.updateMask(mask1.and(mask2).and(mask3))
      .select(L8_BANDS).rename(LTS_NAMES) // Map legacy band names
      .copyProperties(image, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
};


var cloudScore = function(image) {
  // A helper to apply an expression and linearly rescale the output.
  var rescale = function(image, exp, thresholds) {
    return image.expression(exp, {image: image})
        .divide(10000) // need to divide by 10000 (SR)
        .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
  };

  // Compute several indicators of cloudyness and take the minimum of them.
  var score = ee.Image(1.0);
  
  // Clouds are reasonably bright in the blue band.
  score = score.min(rescale(image, 'image.blue', [0.1, 0.3]));

  // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(image, 'image.red + image.green + image.blue', [0.2, 0.8]));

  // Clouds are reasonably bright in all infrared bands.
  score = score.min(
      rescale(image, 'image.nir + image.swir1 + image.swir2', [0.3, 0.8]));

  // Clouds are reasonably cool in temperature.
  score = score.min(rescale(image, 'image.temp', [300, 290]));

  // However, clouds are not snow.
  var ndsi = image.normalizedDifference(['green', 'swir1']);
  return score.min(rescale(ndsi, 'image', [0.8, 0.6]));

}; 

function addCloudScore(image) {
      // Invert the cloudscore so 1 is least cloudy, and rename the band.
      var score = cloudScore(image.select(LTS_NAMES));
      score = ee.Image(1).subtract(score).select([0], ['cloudscore']);
      return image.addBands(score);
// REF: https://gis.stackexchange.com/questions/280400/
// cloud-cover-percentage-in-google-earth-engine 
}

function maskCloudScore(image) {
  var qa = image.select('cloudscore');

  var mask = qa.gte(0.8);
  return image.updateMask(mask)
      .copyProperties(image, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
}
// SOURCE: https://gis.stackexchange.com/questions/280400/
// cloud-cover-percentage-in-google-earth-engine  


function spectralTransforms(img){
  // make sure index string in upper case
  var index = DEPENDENT.toUpperCase();

  var dict = {
    blue: img.select("blue").divide(10000),
    green: img.select("green").divide(10000), // moved divide here
    red: img.select("red").divide(10000),
    nir: img.select("nir").divide(10000),
    swir1: img.select("swir1").divide(10000),
    swir2: img.select("swir2").divide(10000),
  };
  
  var indexImg;
  switch (index){
    case 'NBR':
      indexImg = img.normalizedDifference(['nir', 'swir2'])
        .rename("nbr");
      break;
    case 'NDMI':
      indexImg = img.normalizedDifference(['nir', 'swir1'])
        .rename("ndmi");
      break;
    case 'NDVI':
      indexImg = img.normalizedDifference(['nir', 'red'])
        .rename("ndvi");
      break;
    case 'NDSI':
      indexImg = img.normalizedDifference(['green', 'swir1'])
        .rename("ndsi");
      break;
    case 'EVI':
      indexImg = img.expression(
          '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', 
          {
            'NIR': img.select('nir'),
            'RED': img.select('red'),
            'BLUE': img.select('blue')
        }).rename("evi");
      break;
    case 'TCB':
      indexImg = img.expression("0.2043*blue + 0.4158*green + 0.5524*red + 0.5741*nir + 0.3124*swir1 + 0.2303*swir2", dict)
        .rename("tcb");
      break;
    case 'TCG':
      indexImg = img.expression("-0.1603*blue - 0.2819*green - 0.4934*red + 0.7940*nir - 0.0002*swir1 - 0.1446*swir2", dict)
        .rename("tcg");
      break;
    case 'TCW':
      indexImg = img.expression("0.0315*blue + 0.2021*green + 0.3102*red + 0.1594*nir - 0.6806*swir1 - 0.6109*swir2", dict)
        .rename("tcw");
      break;
    case 'SR':
      indexImg = img.select('nir').divide(img.select('red'))
        .rename("sr");
      break;

    default:
      print('The index you provided is not supported');
  }

  return indexImg
    .copyProperties(img, ["system:time_start", "WRS_PATH", "WRS_ROW"]);
}


var getNames = function(base, list) {
  return ee.List(list).map(function(i) { 
    return ee.String(base).cat(ee.Number(i).int());
  });
};

var addConstant = function(image) {
  return image.addBands(ee.Image(1));
};

var addTime = function(image) {
  // Compute time in fractional years since the epoch.
  var date = ee.Date(image.get('system:time_start'));
  var years = date.difference(ee.Date('1970-01-01'), 'year');
  var timeRadians = ee.Image(years.multiply(2 * Math.PI));
  return image.addBands(timeRadians.rename('t').float());
};

var addHarmonics = function(freqs) {
  return function(image) {
    // Make an image of frequencies.
    var frequencies = ee.Image.constant(freqs);
    // This band should represent time in radians.
    var time = ee.Image(image).select('t');
    // Get the cosine terms.
    var cosines = time.multiply(frequencies).cos()
      .rename(cosNames);
    // Get the sin terms.
    var sines = time.multiply(frequencies).sin()
      .rename(sinNames);
    return image.addBands(cosines).addBands(sines);
  };
};


var getCoeffs = function(feature) {
  var collectionScene = ee.ImageCollection.fromImages(feature.get('images'));
  
  // Calculate number of observations per pixel
  var numObs = collectionScene.count().select(0).rename('nobs')
  var crs = collectionScene.first().projection().crs()
  
  // Add constant, time, and coefficients
  var harmonicLandsat = collectionScene.select(DEPENDENT)
    .map(addConstant)
    .map(addTime)
    .map(addHarmonics(harmonicFrequencies));
    
  // The output of the regression reduction is a 4x1 array image
  var harmonicTrend = harmonicLandsat
    .select(independents.add(DEPENDENT))
    .reduce(ee.Reducer.linearRegression(independents.length(), 1));
  
  // Turn the array image into a multi-band image of coefficients
  var harmonicTrendCoefficients = harmonicTrend.select('coefficients')
    .arrayProject([0])
    .arrayFlatten([independents]);
  
  // Compute fitted values
  var fittedHarmonic = harmonicLandsat.map(function(image) {
    return image.addBands(
      image.select(independents)
        .multiply(harmonicTrendCoefficients)
        .reduce('sum')
        .rename('fitted'));
      });
  
  // Calculate residuals
  var withResiduals = fittedHarmonic.map(function(image) {
    var residuals = image.select(DEPENDENT).subtract(image.select('fitted'))
        .rename('residual');
    var residualsSquared = residuals.pow(2).rename('residualSquared');
    
    return image.addBands([residuals, residualsSquared]);
  });
  
  // Calculate model RMSE
  var rmse = withResiduals.select('residualSquared')
    .mean().sqrt().rename('rmse');
  
  harmonicTrendCoefficients = harmonicTrendCoefficients
    .addBands([rmse, numObs]);
    
  var outputProperties = ee.Dictionary({
    'system:time_start': ee.Date(START_YEAR+'-01-01').millis(),
    'system:time_end': ee.Date(END_YEAR+'-01-01').millis(),
    'spectral_band': DEPENDENT,
    'year_start': START_YEAR,
    'year_end': END_YEAR,
    'version': VERSION,
    'harmonics': HARMONICS,
    'time_series': TS,
    'WRS_PATH': feature.get('PATH'),
    'WRS_ROW': feature.get('ROW')
});
  
  return harmonicTrendCoefficients//.reproject(crs)
    .setMulti(outputProperties);
};

// ------------------------------------- Analysis -------------------------------------- 

// Get specified frequencies
if (HARMONICS == 'h13') {
  var harmonicFrequencies = ee.List([1,3]);
} else if (HARMONICS == 'h12') {
  var harmonicFrequencies = ee.List([1,2]);
}
  
// Construct lists of names for the harmonic terms
var cosNames = getNames('cos_', harmonicFrequencies);
var sinNames = getNames('sin_', harmonicFrequencies);

// Make list of  variables
var independents = ee.List(['constant', 't'])
  .cat(cosNames).cat(sinNames);
  
// Get study area boundaries
var bounds_geo = roi.geometry(); // ROI geoemtry

// Select all available (full) versus limited L7 (16d) time series
if (TS == 'full') {
  
  // Get all Landsat 5 imagery.
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
    .filterBounds(bounds_geo)
    .filterDate(START_YEAR + '-01-01', END_YEAR + '-12-31') // WINDOW
    .filter(ee.Filter.lt('CLOUD_COVER_LAND', 80))
    .map(preprocess457);
  
  // Get all Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
    .filterBounds(bounds_geo)
    .filterDate(START_YEAR + '-01-01', END_YEAR + '-12-31') // WINDOW
    .filter(ee.Filter.lt('CLOUD_COVER_LAND', 80))
    .map(preprocess457);
  
  // Get all Landsat 8 imagery.
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
    .filterBounds(bounds_geo)
    .filterDate(START_YEAR + '-01-01', END_YEAR + '-12-31') // WINDOW
    .map(preprocess8);
    
} else if (TS == '16d') {
  
  // Get all Landsat 5 imagery.
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
    .filterBounds(bounds_geo)
    .filterDate(1985 + '-01-01', 2011 + '-10-31')  // Landsat 5 fails Nov. 2011
    .filterDate(START_YEAR + '-01-01', END_YEAR + '-12-31') // WINDOW
    .filter(ee.Filter.lt('CLOUD_COVER_LAND', 80))
    .map(preprocess457);
  
  // Get Landsat 7 imagery to fill gap period between 5 and 8.
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
    .filterBounds(bounds_geo)
    .filterDate(2011 + '-11-01', 2013 + '-04-10') // Use Landsat 7 only when 5/8 not avail.
    .filterDate(START_YEAR + '-01-01', END_YEAR + '-12-31') // WINDOW
    .filter(ee.Filter.lt('CLOUD_COVER_LAND', 80))
    .map(preprocess457);
  
  // Get all Landsat 8 imagery.
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
    .filterBounds(bounds_geo)
    .filterDate(2013 + '-04-11', 2020 + '-12-31') // Landsat 8 achieves WRS-2 April 11, 2013
    .filterDate(START_YEAR + '-01-01', END_YEAR + '-12-31') // WINDOW
    .map(preprocess8);
}

// Merge pre-processed Landsat 5, 7 and 8 collections
var collection = collection5.merge(collection7).merge(collection8)
  .map(addCloudScore)
  .map(maskCloudScore) // mask based on simple cloud score
  .map(spectralTransforms);


// Get WRS2 Scene boundaries
var scenes = wrs2.filterBounds(bounds_geo);

// Join images by Scene (Path/Row)
var join = ee.Join.saveAll('images', 'system:time_start', true)
var collections = join.apply({
primary: scenes, 
secondary: collection, 
condition: ee.Filter.and(
  ee.Filter.equals({
    leftField: 'PATH', 
    rightField: 'WRS_PATH'
  }), ee.Filter.equals({
    leftField: 'ROW', 
    rightField: 'WRS_ROW'
  })
)
})

// Map over scene collections
var outputFull = ee.ImageCollection(collections.map(getCoeffs));

// Quality mosaic based on number of observations per pixel
var outputMosiac = ee.Image(outputFull.qualityMosaic('nobs')
                     .multiply(OUTPUT_MULTIPLIER)
                     .int() // convert to int
                     .setMulti(outputProperties));
                   
                     
print('Full collection:', outputFull);
print('Mosaic product:', outputMosiac);

Map.addLayer(outputMosiac.select('rmse'), {min:0, max:500}, 'RMSE');

// ------------------------------------- Export -------------------------------------- 

Export.image.toAsset({
  image: outputMosiac,
  description: DEPENDENT + '_' + START_YEAR + '-' + END_YEAR ,
  assetId: DEPENDENT + '_' + START_YEAR + '-' + END_YEAR,
  region: roi.geometry().bounds(),
  crs: OUTPUT_CRS,
  scale: 30,
  maxPixels: 1e13,
})





