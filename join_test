// ----------------------------- Imports & Outputs ---------------------------------- 
 
var utils = require('users/valeriepasquarella/condition_monitoring:utils.js');

var BASELINES_COLLECTION = ee.ImageCollection('projects/sites-project/baselines_v6-3_by_state')


// ---------------------------------- Functions ---------------------------------- 

var spectralTransforms = function(img){
  // make sure index string in upper case
  var index = DEPENDENT.toUpperCase();
  
  var scaled = img.divide(10000);

  var dict = {
    blue: scaled.select("blue"),
    green: scaled.select("green"), 
    red: scaled.select("red"),
    nir: scaled.select("nir"),
    swir1: scaled.select("swir1"),
    swir2: scaled.select("swir2"),
  };
  
  var indexImg;
  switch (index){
    case 'NDVI':
      indexImg = scaled.normalizedDifference(['nir', 'red'])
        .rename("ndvi");
      break;
    case 'EVI':
      indexImg = scaled.expression("2.5 * ((nir - red) / (nir + 6 * red - 7.5 * blue + 1))", dict)
        .rename("evi");
      break;
    case 'TCG':
      indexImg = scaled.expression("-0.1603*blue - 0.2819*green - 0.4934*red + 0.7940*nir - 0.0002*swir1 - 0.1446*swir2", dict)
        .rename("tcg");
      break;
    case 'SR':
      indexImg = scaled.select('nir').divide(scaled.select('red'))
        .rename("sr");
      break;

    default:
      print('The index you provided is not supported');
  }

  return indexImg//.reproject(baseline_crs, null, output_resolution)
    .copyProperties(img, ["system:time_start", "WRS_PATH", "WRS_ROW", "SENSING_TIME"]);
}


var getNames = function(base, list) {
  return ee.List(list).map(function(i) { 
    return ee.String(base).cat(ee.Number(i).int());
  });
};


var addConstant = function(image) {
  return image.addBands(ee.Image(1))
    // .setDefaultProjection(baseline_crs);
};


var addTime = function(image) {
  // Compute time in fractional years since the epoch.
  var date = ee.Date(image.get('system:time_start'));
  var years = date.difference(ee.Date('1970-01-01'), 'year');
  var timeRadians = ee.Image(years.multiply(2 * Math.PI));
  return image.addBands(timeRadians.rename('t').float())
    .setDefaultProjection(ee.Image(baseline).projection().crs());
};


var addHarmonics = function(freqs) {
  return function(image) {
    // Make an image of frequencies.
    var frequencies = ee.Image.constant(freqs)
      // .setDefaultProjection(baseline_crs);
    // This band should represent time in radians.
    var time = ee.Image(image).select('t');
    // Get the cosine terms.
    var cosines = time.multiply(frequencies).cos()
      .rename(cosNames);
    // Get the sin terms.
    var sines = time.multiply(frequencies).sin()
      .rename(sinNames);
    return image.addBands(cosines).addBands(sines);
  };
};


// Function to build monitoring collection
var monitorTS = function(clipBound, monitor_start, monitor_end) {
  
// Get Landsat 5 imagery
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
      .filterDate(monitor_start, monitor_end)  
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 
    
  // Get Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 

  // Get  Landsat 8 imagery
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess8)  

  // Merge collections
  var collection = collection5.merge(collection7).merge(collection8)
      .map(function(image) {return image.set({
          'SENSING_TIME': ee.String(image.get('SENSING_TIME')).split('T').get(0), 
          'WRS_PATH': image.get('WRS_PATH')})
      })
      .map(utils.addCloudScore)
      .map(utils.maskCloudScore) 
      .map(spectralTransforms)
      .sort('system:time_start') 
      
  // Filter endlaps (within-Path)
  var acquisitions = collection.aggregate_array('SENSING_TIME').distinct()
  
  // Take mean for each acquisition date (Path)
  var monitorC = ee.ImageCollection.fromImages(acquisitions.map(function(d) {
    var date = ee.Date(d)
    var date2 = date.advance(24, 'hour')
    var path = collection.filterDate(date, date2).first().get('WRS_PATH')
    
    return collection.filterDate(date, date2).mean()
      .set({
        'system:time_start': date.millis(), 
        'date': date,
        'WRS_PATH': path
      })
  }));
  
  // Return image collection for monitoring period
  return monitorC;
  
  };
  
  
// Function to add predicted value
var addPrediction = function(image) {
  var prediction = image.select(independents)
      .multiply(ee.Image(baseline).select(independents))
      .reduce('sum')
      .rename('fitted')
  var rmse = ee.Image(baseline).select('rmse').rename('rmse')
  var nobs = ee.Image(baseline).select('nobs').rename('nobs')
  var t = ee.Image(baseline).select('t').rename('trend')
  return image.addBands(prediction)
    .addBands(rmse).addBands(nobs).addBands(t);
}

// Function to calculate scores
var addScore = function(image) {
  var observed = image.select(DEPENDENT)
  var prediction = image.select('fitted')
  var score = observed.subtract(prediction)
      .divide(image.select('rmse'))
      
  return image.addBands(score.rename('score'));
}



// var getCoeffs = function(feature) {
//   var baseline_images = ee.ImageCollection.fromImages(feature.get('images'));
//   var baseline = ee.Image(feature)

//   // Add constant, time, and coefficients to monitoring collection.
//   var harmonicLandsat = baseline_images.select(DEPENDENT)
//     .map(addConstant)
//     .map(addTime)
//     .map(addHarmonics(harmonicFrequencies));
  
//   // Add predictions and scores
//   var collectPredictions = harmonicLandsat
//     .map(addPrediction)
//     .map(addScore);
  
//   return collectPredictions;
// };


// ---------------------------------- UI ---------------------------------- 
var CC_THRESH = 50;     
var DEPENDENT = 'tcg'
var MIN_OBS = 30;
var TS = 'full'
var STATES = ['MA']
var monitor_start = '2019-05-01'
var monitor_end = '2019-09-30'

var SCORES_IC = []
var baseline = []

// Harmonic frequences - use 12-month/4-month (h13)
var harmonicFrequencies = ee.List([1,3]);
  
// Construct lists of names for the harmonic terms.
var cosNames = getNames('cos_', harmonicFrequencies);
var sinNames = getNames('sin_', harmonicFrequencies);

// Independent variables.
var independents = ee.List(['constant', 't'])
  .cat(cosNames).cat(sinNames);
  

var experiment_baselines = ee.ImageCollection(BASELINES_COLLECTION
    .filterMetadata('spectral_band', 'equals', DEPENDENT)
    .filter(ee.Filter.inList('state', STATES)) 
    .filterMetadata('harmonics', 'equals', 'h13')
    .filterMetadata('time_series', 'equals', TS))
print(experiment_baselines)

// Get WRS2 paths
var paths = experiment_baselines.aggregate_array('WRS_PATH').distinct()
var num_paths = paths.size().getInfo()

// Get study area boundary
var clip_bound = experiment_baselines.geometry().bounds()

// Get monitoring period imagery
var monitor = monitorTS(clip_bound, monitor_start, monitor_end);
print(monitor)

// Join images by Scene (Path/Row)
var join = ee.Join.saveAll('images', 'system:time_start', true)
var collections = join.apply({
  primary: experiment_baselines, 
  secondary: monitor, 
  condition: 
    ee.Filter.equals({
      leftField: 'WRS_PATH', 
      rightField: 'WRS_PATH'
    })
  })

print(collections)

var baseline = collections.first()
print(baseline)
// Map.addLayer(ee.Image(baseline))


var baseline_images = ee.ImageCollection.fromImages(collections.first().get('images'));
print(baseline_images)


// Add constant, time, and coefficients to monitoring collection.
var harmonicLandsat = baseline_images.select(DEPENDENT)
  .map(addConstant)
  .map(addTime)
  .map(addHarmonics(harmonicFrequencies));

// Add predictions and scores
var collectPredictions = harmonicLandsat
  .map(addPrediction)
  .map(addScore);

print(collectPredictions)
Map.addLayer(collectPredictions)

// var outputFull = ee.ImageCollection(collections.map(getCoeffs))
// print(outputFull)

