// |
// | Landsat Time Series Assessment -- Prediction & Monitoring
// | [valpasq@bu.edu], 2020
// |
// |
// | This script reads a collection of baseline "experiments" and generates
// | a collection of condition assessment scores by experiment/WRS2 Path for
// | a user-specified monitoring period.


// ---------------------------------- Imports & Outputs ---------------------------------- 

var utils = require('users/valeriepasquarella/condition_monitoring:utils.js');

// Specify collection with experiments from 1_baseline_generator
var BASELINES_COLLECTION = ee.ImageCollection('projects/sites-project/baselines_v6-3_by_state')

// Specify collection for saving monitoring results (created using Assets Manager)
var OUTPUT_COLLECTION = 'projects/sites-project/baselines_v6-3_by_state_monitoring/'

// -------------------------------- Monitoring Parameters --------------------------------- 

var STATE = 'MA';

var YEAR = 2017;         // Monitoring year
var DAY_START = '05-01'; // Date to start monitoring
var DAY_END = '09-30';   // Date to end monitoring

var CC_THRESH = 50;     // maximum CLOUD_COVER_LAND 
var OBS_MIN = 30;       // exclude baseline models fit with less than minimum nobs


// -------------------------------- Monitoring Setup -------------------------------- 

var monitor_start = YEAR + '-' + DAY_START;
var monitor_end = YEAR + '-' + DAY_END;

// Get baselines
var experiments = BASELINES_COLLECTION.aggregate_array('name').distinct()
var num_experiments = experiments.size().getInfo()

// Get WRS2 paths
var paths = BASELINES_COLLECTION.aggregate_array('WRS_PATH').distinct()
var num_paths = paths.size().getInfo()

// -------------------------------- Visualization -------------------------------- 
// Default visualization palette used in Pasquarella et al. 2017, 2018

var min = -4;
var max = 0;
var palette = ['red', 'orange', 'yellow', 'blue']
var viz = {min: min, max: max, palette: palette};

// ---------------------------------- Functions ---------------------------------- 

var spectralTransformsFnFactory = function(dependent) {
  return function(img){
    // make sure index string in upper case
    var index = dependent.toUpperCase();
    
    var scaled = img.divide(10000);
  
    var dict = {
      blue: scaled.select("blue"),
      green: scaled.select("green"), 
      red: scaled.select("red"),
      nir: scaled.select("nir"),
      swir1: scaled.select("swir1"),
      swir2: scaled.select("swir2"),
    };
    
    var indexImg;
    switch (index){
      case 'NBR':
        indexImg = scaled.normalizedDifference(['nir', 'swir2'])
          .rename("nbr");
        break;
      case 'NDMI':
        indexImg = scaled.normalizedDifference(['nir', 'swir1'])
          .rename("ndmi");
        break;
      case 'NDVI':
        indexImg = scaled.normalizedDifference(['nir', 'red'])
          .rename("ndvi");
        break;
      case 'NDSI':
        indexImg = scaled.normalizedDifference(['green', 'swir1'])
          .rename("ndsi");
        break;
      case 'EVI':
        indexImg = scaled.expression("2.5 * ((nir - red) / (nir + 6 * red - 7.5 * blue + 1))", dict)
          .rename("evi");
        break;
      case 'TCB':
        indexImg = scaled.expression("0.2043*blue + 0.4158*green + 0.5524*red + 0.5741*nir + 0.3124*swir1 + 0.2303*swir2", dict)
          .rename("tcb");
        break;
      case 'TCG':
        indexImg = scaled.expression("-0.1603*blue - 0.2819*green - 0.4934*red + 0.7940*nir - 0.0002*swir1 - 0.1446*swir2", dict)
          .rename("tcg");
        break;
      case 'TCW':
        indexImg = scaled.expression("0.0315*blue + 0.2021*green + 0.3102*red + 0.1594*nir - 0.6806*swir1 - 0.6109*swir2", dict)
          .rename("tcw");
        break;
      case 'SR':
        indexImg = scaled.select('nir').divide(scaled.select('red'))
          .rename("sr");
        break;
  
      default:
        print('The index you provided is not supported');
    }
  
    return indexImg
      .copyProperties(img, ["system:time_start", "WRS_PATH", "WRS_ROW", "SENSING_TIME"]);
  };
}

var getNames = function(base, list) {
  return ee.List(list).map(function(i) { 
    return ee.String(base).cat(ee.Number(i).int());
  });
};


var addConstant = function(image) {
  return image.addBands(ee.Image(1))
    // .setDefaultProjection(baseline_crs);
};


var addTime = function(image) {
  // Compute time in fractional years since the epoch.
  var date = ee.Date(image.get('system:time_start'));
  var years = date.difference(ee.Date('1970-01-01'), 'year');
  var timeRadians = ee.Image(years.multiply(2 * Math.PI));
  return image.addBands(timeRadians.rename('t').float())
    // .setDefaultProjection(baseline_crs);
};


var addHarmonics = function(freqs) {
  return function(image) {
    // Make an image of frequencies.
    var frequencies = ee.Image.constant(freqs)
      // .setDefaultProjection(baseline_crs);
    // This band should represent time in radians.
    var time = ee.Image(image).select('t');
    // Get the cosine terms.
    var cosines = time.multiply(frequencies).cos()
      .rename(cosNames);
    // Get the sin terms.
    var sines = time.multiply(frequencies).sin()
      .rename(sinNames);
    return image.addBands(cosines).addBands(sines);
  };
};


// Function to build monitoring collection
var monitorTS = function(clipBound, monitor_start, monitor_end, dependent) {
  
// Get Landsat 5 imagery
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
      .filterDate(monitor_start, monitor_end)  
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 
    
  // Get Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 

  // Get  Landsat 8 imagery
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess8)  

  // Create a mappable closure using the dependant variable.
  var spectralTransformFn = spectralTransformsFnFactory(dependent);

  // FINAL LTS COLLECTION
  var collection = collection5.merge(collection7).merge(collection8)
      .map(function(image) {return image.set({
          'SENSING_TIME': ee.String(image.get('SENSING_TIME')).split('T').get(0), 
          'WRS_PATH': image.get('WRS_PATH')})
      })
      .map(utils.addCloudScore)
      .map(utils.maskCloudScore) 
      .map(spectralTransformFn)
      .sort('system:time_start') 
      
  // ENDLAP FILTERING
  var acquisitions = collection.aggregate_array('SENSING_TIME').distinct()
  
  // Take mean for each acquisition date (Path)
  var monitorC = ee.ImageCollection.fromImages(acquisitions.map(function(d) {
    var date = ee.Date(d)
    var date2 = date.advance(24, 'hour')
    var path = collection.filterDate(date, date2).first().get('WRS_PATH')
    
    return collection.filterDate(date, date2).mean()
      .set({
        'system:time_start': date.millis(), 
        'WRS_PATH': path
      })
  }));
  
  // Return image collection for monitoring period
  return monitorC;
  
};
  
  
// Function to add predicted value
var addPrediction = function(image) {
  var prediction = image.select(independents)
      .multiply(baseline.select(independents))
      .reduce('sum')
      .rename('fitted')
  var rmse = baseline.select('rmse').rename('rmse')
  var nobs = baseline.select('nobs').rename('nobs')
  var t = baseline.select('t').rename('trend')
  return image.addBands(prediction)
    .addBands(rmse).addBands(nobs).addBands(t);
}

// Function to calculate scores
var addScore = function(image) {
  var observed = image.select(DEPENDENT)
  var prediction = image.select('fitted')
  var score = observed.subtract(prediction)
      .divide(image.select('rmse'))
      
  return image.addBands(score.rename('score'));
}


// --------------------------------- PREDICT ---------------------------------- 

// Loop over experiments in baselines collection
for(var experiment = 0; experiment < num_experiments; experiment++){
// for(var experiment = 0; experiment < 2; experiment++){
  var experiment_name = experiments.get(experiment)
  // print('Experiment:', experiment_name)
  
  var experiment_baselines = ee.ImageCollection(BASELINES_COLLECTION
    .filterMetadata('name', 'equals', experiment_name)
    .filterMetadata('state', 'equals', STATE))
  // print('Baseline collection:', experiment_baselines)

  var VERSION = experiment_baselines.first().get('version').getInfo()
  var dependent = experiment_baselines.first().get('spectral_band').getInfo()
  var TS = experiment_baselines.first().get('time_series').getInfo()
  var FREQ = experiment_baselines.first().get('harmonics').getInfo()
  var YEAR_START = experiment_baselines.first().get('year_start').getInfo()
  var YEAR_END = experiment_baselines.first().get('year_end').getInfo()
  var REF_PERIOD = YEAR_START + '-' + YEAR_END
  var STATE = experiment_baselines.first().get('state').getInfo()
  
  var OUTPUT_NAME = OUTPUT_COLLECTION + DEPENDENT + '_' + REF_PERIOD + '_' + FREQ + '_' + TS + '_' + monitor_start + '_' + monitor_end

  // Get study area boundary
  var clip_bound = experiment_baselines.geometry().bounds()
  // Map.addLayer(clip_bound)
  
  // get frequencies
  if (FREQ == 'h13') {
    var harmonicFrequencies = ee.List([1,3]);
    
  } else if (FREQ == 'h12') {
    var harmonicFrequencies = ee.List([1,2]);
  }
  
  // Construct lists of names for the harmonic terms.
  var cosNames = getNames('cos_', harmonicFrequencies);
  var sinNames = getNames('sin_', harmonicFrequencies);
  
  // Independent variables.
  var independents = ee.List(['constant', 't'])
    .cat(cosNames).cat(sinNames);
  
  // Get monitoring period imagery
  var monitor = monitorTS(clip_bound, monitor_start, monitor_end, dependent);
  // print('Full monitoring collection:', monitor)
  
  
  for(var i = 0; i < num_paths; i++){
    var path = paths.get(i).getInfo()
    // print('Path:', path)
    
    var baseline = experiment_baselines
      .filterMetadata('WRS_PATH', 'equals', path)
      .first()
      // .divide(10000)
    baseline = baseline.updateMask(baseline.select('nobs').gte(OBS_MIN))
    // print(baseline.projection().crs())

    var monitor_subset = monitor.filterMetadata('WRS_PATH', 'equals', path)
    // print('Monitoring dates within Path:', monitor_subset)
  
    // Add constant, time, and coefficients to monitoring collection.
    var harmonicLandsat = monitor_subset.select(DEPENDENT)
      .map(addConstant)
      .map(addTime)
      .map(addHarmonics(harmonicFrequencies));
    
    // Add predictions and scores
    var collectPredictions = harmonicLandsat
      .map(addPrediction)
      .map(addScore);
    // print('Collection of results for Path', collectPredictions)
    
    var mean = collectPredictions.select('score').reduce('mean');
    var stddev = collectPredictions.select('score').reduce('stdDev');
    var nobs = collectPredictions.select('score').reduce('count');
    
    // Dictionary for asset properties
    var outputProperties = ee.Dictionary({
          'system:time_start': ee.Date(monitor_start).millis(),
          'spectral_band': DEPENDENT,
          'monitor_year': YEAR,
          'monitor_start': monitor_start,
          'monitor_end': monitor_end,
          'run_version': VERSION,
          'harmonics': FREQ,
          'time_series': TS,
          'ref_period': REF_PERIOD,
          'name': experiment_name,
          'WRS_PATH': path,
          'state': STATE
      });
    
    // Average over monitoring period
    var assessment = ee.Image(mean.addBands(stddev).addBands(nobs)
        .clip(clip_bound)
        .setMulti(outputProperties))
    // print('Assessment:', assessment)
    
    var layer_name = 'Path ' + path
    Map.addLayer(assessment.select('score_mean'), viz, layer_name)
    
    Export.image.toAsset({
      image: assessment,
      description: DEPENDENT + '_' + YEAR_START + '-' + YEAR_END + '_monitor-' + path,
      assetId: OUTPUT_NAME + '_p' + path + '_' + STATE,
      region: clip_bound,
      crs: baseline.projection().crs(),
      scale: 30,
      maxPixels: 1e13,
    })

  }
  
}


  