// |
// | Landsat Time Series Assessment -- Prediction & Monitoring
// | [valpasq@bu.edu], 2020
// |
// |
// | This script reads a collection of baseline "experiments" and generates
// | a collection of condition assessment scores by experiment/WRS2 Path for
// | a user-specified monitoring period.


// ---------------------------------- Imports & Outputs ---------------------------------- 

var utils = require('users/valeriepasquarella/condition_monitoring:utils.js');

// Specify collection with experiments from 1_baseline_generator
var BASELINES_COLLECTION = ee.ImageCollection('projects/sites-project/baselines_v6-3_by_state')

// Specify collection for saving monitoring results (created using Assets Manager)
var OUTPUT_COLLECTION = 'projects/sites-project/baselines_v6-3_by_state_monitoring/'

// -------------------------------- Monitoring Parameters --------------------------------- 

var STATE = 'MA';

var YEAR = 2017;         // Monitoring year
var DAY_START = '05-01'; // Date to start monitoring
var DAY_END = '09-30';   // Date to end monitoring

var CC_THRESH = 50;     // maximum CLOUD_COVER_LAND 
var OBS_MIN = 30;       // exclude baseline models fit with less than minimum nobs


// -------------------------------- Monitoring Setup -------------------------------- 

var monitor_start = YEAR + '-' + DAY_START;
var monitor_end = YEAR + '-' + DAY_END;

// Get baselines
var baselines_for_state = BASELINES_COLLECTION.filterMetadata('state', 'equals', 'MA')
var experiments = baselines_for_state.aggregate_array('name').distinct()
var num_experiments = experiments.size().getInfo()

// Get WRS2 paths
var paths = baselines_for_state.aggregate_array('WRS_PATH').distinct()
var num_paths = paths.size().getInfo()
print(paths)

// -------------------------------- Visualization -------------------------------- 
// Default visualization palette used in Pasquarella et al. 2017, 2018

var min = -4;
var max = 0;
var palette = ['red', 'orange', 'yellow', 'blue']
var viz = {min: min, max: max, palette: palette};

// ---------------------------------- Functions ---------------------------------- 

// Function to build monitoring collection
var monitorTS = function(clipBound, monitor_start, monitor_end, dependent) {
  
// Get Landsat 5 imagery
  var collection5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
      .filterDate(monitor_start, monitor_end)  
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 
    
  // Get Landsat 7 imagery
  var collection7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess457) 

  // Get  Landsat 8 imagery
  var collection8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
      .filterDate(monitor_start, monitor_end) 
      .filterBounds(clipBound) 
      .filterMetadata('CLOUD_COVER_LAND', "less_than", CC_THRESH)
      .map(utils.preprocess8)  


  // FINAL LTS COLLECTION
  var collection = collection5.merge(collection7).merge(collection8)
      .map(function(image) {return image.set({
          'SENSING_TIME': ee.String(image.get('SENSING_TIME')).split('T').get(0), 
          'WRS_PATH': image.get('WRS_PATH')})
      })
      .map(utils.addCloudScore)
      .map(utils.maskCloudScore) 
      .map(utils.spectralTransformsFnFactory(dependent))
      .sort('system:time_start') 
      
  // ENDLAP FILTERING
  var acquisitions = collection.aggregate_array('SENSING_TIME').distinct()
  
  // Take mean for each acquisition date (Path)
  var monitorC = ee.ImageCollection.fromImages(acquisitions.map(function(d) {
    var date = ee.Date(d)
    var date2 = date.advance(24, 'hour')
    var path = collection.filterDate(date, date2).first().get('WRS_PATH')
    
    return collection.filterDate(date, date2).mean()
      .set({
        'system:time_start': date.millis(), 
        'WRS_PATH': path
      })
  }));
  
  // Return image collection for monitoring period
  return monitorC;
};
  
  
// Function to add predicted value
var addPrediction = function(image) {
  var prediction = image.select(independents)
      .multiply(baseline.select(independents))
      .reduce('sum')
      .rename('fitted')
  var rmse = baseline.select('rmse').rename('rmse')
  var nobs = baseline.select('nobs').rename('nobs')
  var t = baseline.select('t').rename('trend')
  return image.addBands(prediction)
    .addBands(rmse).addBands(nobs).addBands(t);
}

// Function to calculate scores
var addScoreFnFactory = function(dependent) {
  return function(image) {
    var observed = image.select(dependent)
    var prediction = image.select('fitted')
    var score = observed.subtract(prediction)
        .divide(image.select('rmse'))
        
    return image.addBands(score.rename('score'));
  };
}


// --------------------------------- PREDICT ---------------------------------- 

// Loop over experiments in baselines collection
for(var experiment = 0; experiment < num_experiments; experiment++){
// for(var experiment = 0; experiment < 2; experiment++){
  var experiment_name = experiments.get(experiment)
  // print('Experiment:', experiment_name)
  
  var experiment_baselines = ee.ImageCollection(BASELINES_COLLECTION
    .filterMetadata('name', 'equals', experiment_name)
    .filterMetadata('state', 'equals', STATE));
  // print('Baseline collection:', experiment_baselines)

  var baseline_element = experiment_baselines.first();

  var version = baseline_element.get('version').getInfo()
  var dependent = baseline_element.get('spectral_band').getInfo()
  var ts = baseline_element.get('time_series').getInfo()
  var freq = baseline_element.get('harmonics').getInfo()
  var year_start = baseline_element.get('year_start').getInfo()
  var year_end = baseline_element.get('year_end').getInfo()
  var ref_period = year_start + '-' + year_end

  var output_name = OUTPUT_COLLECTION + dependent + '_' + ref_period + '_' + freq + '_' + ts + '_' + monitor_start + '_' + monitor_end

  // Get study area boundary
  var clip_bound = experiment_baselines.geometry().bounds()
  // Map.addLayer(clip_bound)
  
  // get frequencies
  if (freq == 'h13') {
    var harmonicFrequencies = ee.List([1,3]);
    
  } else if (freq == 'h12') {
    var harmonicFrequencies = ee.List([1,2]);
  }
  
  // Construct lists of names for the harmonic terms.
  var cosNames = utils.getNames('cos_', harmonicFrequencies);
  var sinNames = utils.getNames('sin_', harmonicFrequencies);
  
  // Independent variables.
  var independents = ee.List(['constant', 't'])
    .cat(cosNames).cat(sinNames);
  
  // Get monitoring period imagery
  var monitor = monitorTS(clip_bound, monitor_start, monitor_end, dependent);
  // print('Full monitoring collection:', monitor)
  
  
  for(var i = 0; i < num_paths; i++){
    var path = paths.get(i).getInfo()
    // print('Path:', path)
    
    var baseline = experiment_baselines
      .filterMetadata('WRS_PATH', 'equals', path)
      .first()
      // .divide(10000)
    baseline = baseline.updateMask(baseline.select('nobs').gte(OBS_MIN))
    // print(baseline.projection().crs())

    var monitor_subset = monitor.filterMetadata('WRS_PATH', 'equals', path)
    // print('Monitoring dates within Path:', monitor_subset)
  
    // Add constant, time, and coefficients to monitoring collection.
    var harmonicLandsat = monitor_subset.select(dependent)
      .map(utils.addConstant)
      .map(utils.addTime)
      .map(utils.addHarmonicsFnFactory(harmonicFrequencies, cosNames, sinNames));
    
    // Add predictions and scores
    var collectPredictions = harmonicLandsat
      .map(addPrediction)
      .map(addScoreFnFactory(dependent));
    print('Collection of results for Path', collectPredictions)
    
    var mean = collectPredictions.select('score').reduce('mean');
    var stddev = collectPredictions.select('score').reduce('stdDev');
    var nobs = collectPredictions.select('score').reduce('count');
    
    // Dictionary for asset properties
    var outputProperties = ee.Dictionary({
          'system:time_start': ee.Date(monitor_start).millis(),
          'spectral_band': dependent,
          'monitor_year': YEAR,
          'monitor_start': monitor_start,
          'monitor_end': monitor_end,
          'run_version': version,
          'harmonics': freq,
          'time_series': ts,
          'ref_period': ref_period,
          'name': experiment_name,
          'WRS_PATH': path,
          'state': STATE
      });
    
    // Average over monitoring period
    var assessment = ee.Image(mean.addBands(stddev).addBands(nobs)
        .clip(clip_bound)
        .setMulti(outputProperties));
    // print('Assessment:', assessment)
    
    var layer_name = 'Path ' + path;
    Map.addLayer(assessment.select('score_mean'), viz, layer_name);
    
    Export.image.toAsset({
      image: assessment,
      description: dependent + '_' + year_start + '-' + year_end + '_monitor-' + path,
      assetId: output_name + '_p' + path + '_' + STATE,
      region: clip_bound,
      crs: baseline.projection().crs(),
      scale: 30,
      maxPixels: 1e13,
    });

  }
  
}


  