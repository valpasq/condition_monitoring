// |
// | Landsat Time Series Harmonic Condition Assessment -- 
// | Combined monitoring results
// | 
// | [valpasq@bu.edu], 2020
// |
// |
// | This script reads in assessments generated for individual Paths
// | and combines them into a final wall-to-wall assessment product
// | to produce a single map per state

// ---------------------------------- Imports & Outputs ---------------------------------- 
var VERSION = '7-1';

var ROOT = 'projects/sites-project/';

var RESULTS_COLLECTION = ee.ImageCollection(ROOT + 'baselines_v' + VERSION + '_by_state_monitoring');

var OUTPUT_COLLECTION = ROOT + 'baselines_v' + VERSION + '_by_state_products/';
var OUTPUT_CRS = 'EPSG:5070';

var STATE = 'MA';

// -------------------------------- Assessment Parameters --------------------------------- 

var START_ASSESS = 2015;
var END_ASSESS = 2020;

// var MIN_MONITOR_NOBS = 3;
// var MIN_RMSE_SCORE = -10;

// -------------------------------- Monitoring Info -------------------------------- 

var DEPENDENT = RESULTS_COLLECTION.first().get('spectral_band').getInfo()

// -------------------------------- Visualization --------------------------------- 
// Default visualization palette used in Pasquarella et al. 2017, 2018

var MIN = -4;
var MAX = 0;
var PALETTE = ['red', 'orange', 'yellow', 'blue'];
var viz = {min: MIN, max: MAX, palette: PALETTE};

var THRESHOLD = -2;

// -------------------------------- Functions --------------------------------- 

var weightScore = function(image) {
 var score = image.select('score_mean');
 var nobs = image.select(DEPENDENT + '_count');
 var variance = image.select('score_stddev').pow(2);
 
// nobs = nobs.updateMask(nobs.gte(MIN_MONITOR_NOBS))
// nobs = nobs.updateMask(score.gte(MIN_RMSE_SCORE))
 
 var weighted_mean = score.multiply(nobs).rename('mean_wt')
 var weighted_var = variance.multiply(nobs).rename('var_wt')
 
 return image.addBands(weighted_mean)
    .addBands(weighted_var)
    .reproject(OUTPUT_CRS, null, 30)
}

// -------------------------------- Assessment --------------------------------- 
var bounds = RESULTS_COLLECTION.geometry().bounds()

var years = RESULTS_COLLECTION
    .filterMetadata('monitor_year', 'not_less_than', START_ASSESS)
    .filterMetadata('monitor_year', 'not_greater_than', END_ASSESS)
    .aggregate_array('monitor_year')
    .distinct()
var num_years = years.size().getInfo()
print(years)


for(var year = 0; year < num_years; year++){
  var year_value = years.get(year)
  
  var result = ee.ImageCollection(RESULTS_COLLECTION
    .filterMetadata('state', 'equals', STATE)
    .filterMetadata('monitor_year', 'equals', year_value))
  print(result)
  
  // Get total number of observations per pixel
  var total_obs = result.select(DEPENDENT + '_count').reduce('sum')
    .reproject(OUTPUT_CRS, null, 30)
  
  // Weight mean scores by nobs per Path
  var weighted = result.map(weightScore)
  
  // Compute weighted mean
  var final_mean = ee.Image(weighted.select('mean_wt')
    .reduce('sum')
    .divide(total_obs));
  var final_stddev = ee.Image(weighted.select('var_wt')
    .reduce('sum')
    .divide(total_obs)
    .sqrt());
  
  var resultFinal = ee.Image(final_mean.addBands(final_stddev)
    .addBands(total_obs)
    .rename(['weighted_mean', 'weighted_stdddev', 'total_nobs'])
    .copyProperties(result.first(), null, ['WRS_PATH']))
  print(resultFinal)
  // resultFinal = resultFinal
  //     .updateMask(resultFinal.select('score_weighted').gte(-100))
  
  var score_disp = resultFinal
    // .focal_mean(30, 'circle', 'meters', 1);
  var thresh_mask = score_disp.select('weighted_mean').lte(THRESHOLD);
  score_disp = score_disp.updateMask(thresh_mask);
  
  var confidence_scale = ee.Image(1)
    .divide(score_disp.select('weighted_stdddev').add(1))
    .pow(0.6)
    .subtract(0.5).multiply(7)
    .tanh()
    .add(1).multiply(0.5);

  var score_mean_viz_alpha = score_disp.select('weighted_mean')
      .visualize(viz)
      .toUint8()
      .updateMask(thresh_mask.multiply(confidence_scale));
  
  var year_str = year_value.getInfo()
  Map.addLayer(score_mean_viz_alpha, {}, 'weighted score', true)
  Map.addLayer(score_disp, {}, 'hidden', false)
  
  // Export final product for full study area
  Export.image.toAsset({
    image: resultFinal,
    description: 'result_' + year_str + '_' + STATE,
    assetId: OUTPUT_COLLECTION + year_str + '_' + STATE,
    region: bounds,
    crs: OUTPUT_CRS,
    scale: 30,
    maxPixels: 1e13,
  })
}
// }

var style = {
  'Figure': [{
      featureType: 'all',
      stylers: [{ color: '#000000'}]
  }]
};

Map.setOptions(null, style);
Map.setOptions('SATELLITE')
